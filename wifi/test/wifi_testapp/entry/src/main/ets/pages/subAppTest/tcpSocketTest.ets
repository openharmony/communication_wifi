/**
 * Copyright (c) 2022 Shenzhen Kaihong Digital Industry Development Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import socket from '@ohos.net.socket';
import connection from '@ohos.net.connection';
import ConfigData from '../../utils/ConfigData';
import { TestImageDisplay } from '../../Component/testImageDisplay';
import { PageTitle } from '../../Component/pageTitle';
import { TestData } from '../../entryability/model/testData'
import router from '@ohos.router';

interface myParams extends Object {
  testItem: TestData
}


export interface NetAddress {
  address: string;
  family?: number; 
  port?: number; 
}

export interface TCPConnectOptions {
  address: NetAddress;
  timeout?: number;
}

// å®šä¹‰è¿æ¥å‚æ•°æ¥å£
interface ConnectParams {
  address: string;
  port: string;
}

const TAG = 'wifiTestApp [tcpSocketTest]';

/**
 * TCP Socket Test Page Of Wifi test
 */
@Entry
@Component
struct TcpSocketTest {
  @State mode: string = 'client'; // 'client' æˆ– 'server'
  @State serverAddress: string = '192.168.1.100';
  @State serverPort: string = '8080';
  @State localPort: string = '8080'; // æœåŠ¡ç«¯ç›‘å¬ç«¯å£
  @State message: string = 'Hello TCP Server';
  @State responseData: string = '';
  @State isConnected: boolean = false;
  @State isServerRunning: boolean = false;
  @State connectionStatus: string = 'æœªè¿æ¥';
  @State networkStatus: string = 'æ£€æµ‹ä¸­...';
  @State networkType: string = 'æœªçŸ¥';
  @State reconnectCount: number = 0;
  @State clientCount: number = 0; // å·²è¿æ¥çš„å®¢æˆ·ç«¯æ•°é‡
  private tcpSocket: socket.TCPSocket | null = null;
  private serverSocket: socket.TCPSocket | null = null; // æœåŠ¡ç«¯Socket
  private clientSockets: socket.TCPSocket[] = []; // å·²è¿æ¥çš„å®¢æˆ·ç«¯Socketåˆ—è¡¨
  private shouldReconnect: boolean = false;
  private lastConnectParams: ConnectParams | null = null;
  private netConnection: connection.NetConnection | null = null;
  private testItem: TestData = (router.getParams() as myParams).testItem

  aboutToAppear() {
    this.initSocket();
    this.registerNetworkListener();
    this.checkCurrentNetwork();
  }

  initSocket() {
    this.tcpSocket = socket.constructTCPSocketInstance();
  }

  // æ³¨å†Œç½‘ç»œç›‘å¬
  registerNetworkListener() {
    try {
      // åˆ›å»º NetConnection å¯¹è±¡
      this.netConnection = connection.createNetConnection();
      
      // ç›‘å¬ç½‘ç»œå¯ç”¨äº‹ä»¶
      this.netConnection.on('netAvailable', (netHandle: connection.NetHandle) => {
        console.log(TAG, `ç½‘ç»œå¯ç”¨: netId=${netHandle.netId}`);
        this.networkStatus = 'ç½‘ç»œå¯ç”¨';
        this.handleNetworkChange();
      });

      // ç›‘å¬ç½‘ç»œèƒ½åŠ›å˜åŒ–
      this.netConnection.on('netCapabilitiesChange', (netCapabilityInfo: connection.NetCapabilityInfo) => {
        console.log(TAG, `ç½‘ç»œèƒ½åŠ›å˜åŒ–: ${JSON.stringify(netCapabilityInfo)}`);
        if (netCapabilityInfo.netCap) {
          this.updateNetworkType(netCapabilityInfo.netCap);
        }
        this.handleNetworkChange();
      });

      // ç›‘å¬ç½‘ç»œä¸¢å¤±
      this.netConnection.on('netLost', (netHandle: connection.NetHandle) => {
        console.log(TAG, `ç½‘ç»œä¸¢å¤±: netId=${netHandle.netId}`);
        this.networkStatus = 'ç½‘ç»œæ–­å¼€';
        this.responseData += '\n[ç³»ç»Ÿ] ç½‘ç»œè¿æ¥ä¸¢å¤±';
      });

      // æ³¨å†Œç›‘å¬
      this.netConnection.register((error: Error) => {
        if (error) {
          console.error(TAG, `æ³¨å†Œç½‘ç»œç›‘å¬å¤±è´¥: ${JSON.stringify(error)}`);
          this.networkStatus = 'ç›‘å¬æ³¨å†Œå¤±è´¥';
        } else {
          console.log(TAG, 'ç½‘ç»œç›‘å¬å·²æ³¨å†Œ');
        }
      });
    } catch (error) {
      console.error(TAG, `åˆ›å»ºç½‘ç»œç›‘å¬å¤±è´¥: ${JSON.stringify(error)}`);
      this.networkStatus = 'ç›‘å¬åˆ›å»ºå¤±è´¥';
    }
  }

  // æ£€æŸ¥å½“å‰ç½‘ç»œçŠ¶æ€
  async checkCurrentNetwork() {
    try {
      const netHandle = await connection.getDefaultNet();
      const netCapabilities = await connection.getNetCapabilities(netHandle);
      this.updateNetworkType(netCapabilities);
      this.networkStatus = 'ç½‘ç»œæ­£å¸¸';
      console.log(TAG, `å½“å‰ç½‘ç»œç±»å‹: ${this.networkType}`);
    } catch (error) {
      console.error(TAG, `è·å–ç½‘ç»œçŠ¶æ€å¤±è´¥: ${JSON.stringify(error)}`);
      this.networkStatus = 'æ— ç½‘ç»œ';
      this.networkType = 'æœªè¿æ¥';
    }
  }

  // æ›´æ–°ç½‘ç»œç±»å‹æ˜¾ç¤º
  updateNetworkType(netCapabilities: connection.NetCapabilities) {
    if (netCapabilities.bearerTypes.includes(connection.NetBearType.BEARER_WIFI)) {
      this.networkType = 'WiFi';
    } else if (netCapabilities.bearerTypes.includes(connection.NetBearType.BEARER_CELLULAR)) {
      this.networkType = 'èœ‚çªç½‘ç»œ';
    } else if (netCapabilities.bearerTypes.includes(connection.NetBearType.BEARER_ETHERNET)) {
      this.networkType = 'ä»¥å¤ªç½‘';
    } else {
      this.networkType = 'å…¶ä»–';
    }
  }

  // å¤„ç†ç½‘ç»œå˜åŒ–
  handleNetworkChange() {
    console.log(TAG, 'æ£€æµ‹åˆ°ç½‘ç»œå˜åŒ–');
    this.responseData += `\n[ç³»ç»Ÿ] æ£€æµ‹åˆ°ç½‘ç»œå˜åŒ–ï¼Œå½“å‰ç½‘ç»œ: ${this.networkType}`;
    
    // å¦‚æœå½“å‰æœ‰è¿æ¥ï¼Œéœ€è¦é‡è¿
    if (this.isConnected && this.lastConnectParams) {
      this.reconnectCount++;
      this.responseData += `\n[ç³»ç»Ÿ] å‡†å¤‡é‡è¿ (ç¬¬${this.reconnectCount}æ¬¡)...`;
      
      // å…ˆå…³é—­æ—§è¿æ¥
      this.closeSocketForReconnect();
      
      // å»¶è¿Ÿ1ç§’åé‡è¿ï¼Œç­‰å¾…æ–°ç½‘ç»œç¨³å®š
      setTimeout(() => {
        this.reconnectToServer();
      }, 1000);
    }
  }

  // å…³é—­Socketç”¨äºé‡è¿
  async closeSocketForReconnect() {
    if (this.tcpSocket) {
      try {
        await this.tcpSocket.close();
        console.log(TAG, 'æ—§Socketå·²å…³é—­ï¼Œå‡†å¤‡é‡è¿');
      } catch (error) {
        console.error(TAG, `å…³é—­æ—§Socketå¤±è´¥: ${JSON.stringify(error)}`);
      }
      // åˆ›å»ºæ–°çš„Socketå®ä¾‹
      this.tcpSocket = socket.constructTCPSocketInstance();
      this.isConnected = false;
    }
  }

  // é‡æ–°è¿æ¥åˆ°æœåŠ¡å™¨
  async reconnectToServer() {
    if (this.lastConnectParams) {
      console.log(TAG, `å¼€å§‹é‡è¿åˆ° ${this.lastConnectParams.address}:${this.lastConnectParams.port}`);
      this.connectionStatus = 'é‡è¿ä¸­...';
      // æ¢å¤ä¹‹å‰çš„è¿æ¥å‚æ•°
      this.serverAddress = this.lastConnectParams.address;
      this.serverPort = this.lastConnectParams.port;
      // æ‰§è¡Œè¿æ¥
      await this.connectToServer();
    }
  }

  async connectToServer() {
    if (!this.tcpSocket) {
      this.responseData = 'é”™è¯¯: Socketæœªåˆå§‹åŒ–';
      return;
    }

    try {
      this.connectionStatus = 'è¿æ¥ä¸­...';
      if (!this.responseData) {
        this.responseData = '';
      }

      // ä¿å­˜è¿æ¥å‚æ•°ï¼Œç”¨äºç½‘ç»œå˜åŒ–æ—¶é‡è¿
      const params: ConnectParams = {
        address: this.serverAddress,
        port: this.serverPort
      };
      this.lastConnectParams = params;

      // ç»‘å®šæœ¬åœ°åœ°å€ï¼ˆå¯é€‰ï¼‰
      const bindAddress: NetAddress = { address: '0.0.0.0', port: 0, family: 1 };
      await this.tcpSocket.bind(bindAddress);

      // è¿æ¥åˆ°æœåŠ¡å™¨
      const serverAddress: NetAddress = {
        address: this.serverAddress,
        port: parseInt(this.serverPort),
        family: 1
      };
      const connectOptions: TCPConnectOptions = {
        address: serverAddress,
        timeout: 60000
      };
      await this.tcpSocket.connect(connectOptions);

      this.isConnected = true;
      this.connectionStatus = 'å·²è¿æ¥';
      this.responseData += `\næˆåŠŸè¿æ¥åˆ° ${this.serverAddress}:${this.serverPort}`;

      // è®¾ç½®æ¶ˆæ¯æ¥æ”¶å›è°ƒ
      this.tcpSocket.on('message', (data) => {
        const receivedData = data.message.toString();
        console.log(TAG, `æ”¶åˆ°æ•°æ®: ${receivedData}`);
        this.responseData += `\næ”¶åˆ°: ${receivedData}`;
      });

      // è®¾ç½®é”™è¯¯å›è°ƒ
      this.tcpSocket.on('error', (err) => {
        console.error(TAG, `Socketé”™è¯¯: ${JSON.stringify(err)}`);
        this.responseData += `\né”™è¯¯: ${JSON.stringify(err)}`;
        this.isConnected = false;
        this.connectionStatus = 'è¿æ¥é”™è¯¯';
      });

      // è®¾ç½®å…³é—­å›è°ƒ
      this.tcpSocket.on('close', () => {
        console.log(TAG, 'Socketè¿æ¥å·²å…³é—­');
        this.responseData += '\nè¿æ¥å·²å…³é—­';
        this.isConnected = false;
        this.connectionStatus = 'è¿æ¥å·²å…³é—­';
      });

    } catch (error) {
      console.error(TAG, `è¿æ¥å¤±è´¥: ${JSON.stringify(error)}`);
      this.responseData = `è¿æ¥å¤±è´¥: ${JSON.stringify(error)}`;
      this.isConnected = false;
      this.connectionStatus = 'è¿æ¥å¤±è´¥';
    }
  }

  async sendMessage() {
    if (!this.tcpSocket || !this.isConnected) {
      this.responseData += '\né”™è¯¯: æœªè¿æ¥åˆ°æœåŠ¡å™¨';
      return;
    }

    try {
      await this.tcpSocket.send({
        data: this.message,
        encoding: 'utf8'
      });
      this.responseData += `\nå‘é€: ${this.message}`;
      console.log(TAG, `å‘é€æ¶ˆæ¯: ${this.message}`);
    } catch (error) {
      console.error(TAG, `å‘é€å¤±è´¥: ${JSON.stringify(error)}`);
      this.responseData += `\nå‘é€å¤±è´¥: ${JSON.stringify(error)}`;
    }
  }

  async disconnectFromServer() {
    if (!this.tcpSocket) {
      return;
    }

    try {
      await this.tcpSocket.close();
      this.isConnected = false;
      this.connectionStatus = 'å·²æ–­å¼€';
      this.responseData += '\nä¸»åŠ¨æ–­å¼€è¿æ¥';
    } catch (error) {
      console.error(TAG, `æ–­å¼€è¿æ¥å¤±è´¥: ${JSON.stringify(error)}`);
      this.responseData += `\næ–­å¼€è¿æ¥å¤±è´¥: ${JSON.stringify(error)}`;
    }
  }

  clearResponse() {
    this.responseData = '';
  }

  // å¯åŠ¨TCPæœåŠ¡ç«¯
  async startServer() {
    try {
      this.responseData = '';
      this.responseData += `[æœåŠ¡ç«¯] æ­£åœ¨å¯åŠ¨æœåŠ¡...\n`;
      
      // æ³¨æ„ï¼šHarmonyOSçš„æ ‡å‡†socket APIä¸»è¦æ”¯æŒå®¢æˆ·ç«¯åŠŸèƒ½
      // è¿™é‡Œä½¿ç”¨bindæ¥ç»‘å®šæœ¬åœ°ç«¯å£ï¼Œæ¨¡æ‹ŸæœåŠ¡ç«¯ç›‘å¬
      this.serverSocket = socket.constructTCPSocketInstance();
      
      const bindAddress: NetAddress = {
        address: '0.0.0.0',
        port: parseInt(this.localPort),
        family: 1
      };

      await this.serverSocket.bind(bindAddress);
      this.isServerRunning = true;
      
      this.responseData += `[æœåŠ¡ç«¯] æœåŠ¡å·²å¯åŠ¨ï¼Œç›‘å¬ç«¯å£: ${this.localPort}\n`;
      this.responseData += `[æœåŠ¡ç«¯] æœ¬åœ°IP: è¯·åœ¨è®¾ç½®ä¸­æŸ¥çœ‹WiFiä¿¡æ¯è·å–æœ¬æœºIPåœ°å€\n`;
      this.responseData += `[æç¤º] å…¶ä»–è®¾å¤‡å¯ä½¿ç”¨å®¢æˆ·ç«¯æ¨¡å¼è¿æ¥åˆ°æœ¬æœºIP:${this.localPort}\n\n`;
      
      // æ³¨æ„ï¼šæ ‡å‡†TCPSocket APIæ²¡æœ‰acceptæ–¹æ³•
      // å®é™…çš„æœåŠ¡ç«¯å®ç°éœ€è¦ä½¿ç”¨TCPSocketServer APIï¼ˆå¦‚æœå¯ç”¨ï¼‰
      // æˆ–è€…ä½¿ç”¨å…¶ä»–æ–¹å¼å¦‚è½¯æ€»çº¿ã€åˆ†å¸ƒå¼èƒ½åŠ›ç­‰
      this.responseData += `[è¯´æ˜] HarmonyOSæ ‡å‡†Socket APIä¸»è¦ç”¨äºå®¢æˆ·ç«¯è¿æ¥\n`;
      this.responseData += `[è¯´æ˜] å®Œæ•´çš„æœåŠ¡ç«¯åŠŸèƒ½å¯èƒ½éœ€è¦ä½¿ç”¨ï¼š\n`;
      this.responseData += `  1. è½¯æ€»çº¿ï¼ˆSoftbusï¼‰è¿›è¡Œè®¾å¤‡é—´é€šä¿¡\n`;
      this.responseData += `  2. åˆ†å¸ƒå¼æ•°æ®ç®¡ç†\n`;
      this.responseData += `  3. æˆ–ç­‰å¾…åç»­APIç‰ˆæœ¬æ”¯æŒTCPSocketServer\n\n`;
      
      // è®¾ç½®æ¶ˆæ¯æ¥æ”¶å›è°ƒï¼ˆå¦‚æœæœ‰æ•°æ®åˆ°è¾¾ï¼‰
      this.serverSocket.on('message', (data) => {
        const receivedData = data.message.toString();
        const remoteInfo = data.remoteInfo;
        console.log(TAG, `[æœåŠ¡ç«¯] æ”¶åˆ°æ•°æ®: ${receivedData}, æ¥è‡ª: ${remoteInfo.address}:${remoteInfo.port}`);
        this.responseData += `[æ”¶åˆ°] ${receivedData} (æ¥è‡ª: ${remoteInfo.address}:${remoteInfo.port})\n`;
        
        // è‡ªåŠ¨å›å¤ç¡®è®¤æ¶ˆæ¯
        this.sendServerResponse(receivedData, remoteInfo);
      });

      // è®¾ç½®é”™è¯¯å›è°ƒ
      this.serverSocket.on('error', (err) => {
        console.error(TAG, `[æœåŠ¡ç«¯] Socketé”™è¯¯: ${JSON.stringify(err)}`);
        this.responseData += `[é”™è¯¯] ${JSON.stringify(err)}\n`;
      });

      // è®¾ç½®å…³é—­å›è°ƒ
      this.serverSocket.on('close', () => {
        console.log(TAG, '[æœåŠ¡ç«¯] Socketå·²å…³é—­');
        this.responseData += '[æœåŠ¡ç«¯] Socketå·²å…³é—­\n';
        this.isServerRunning = false;
      });

    } catch (error) {
      console.error(TAG, `[æœåŠ¡ç«¯] å¯åŠ¨å¤±è´¥: ${JSON.stringify(error)}`);
      this.responseData += `[é”™è¯¯] å¯åŠ¨æœåŠ¡å¤±è´¥: ${JSON.stringify(error)}\n`;
      this.isServerRunning = false;
    }
  }

  // åœæ­¢TCPæœåŠ¡ç«¯
  async stopServer() {
    try {
      if (this.serverSocket) {
        await this.serverSocket.close();
        this.serverSocket = null;
      }
      
      // å…³é—­æ‰€æœ‰å®¢æˆ·ç«¯è¿æ¥
      for (const clientSocket of this.clientSockets) {
        try {
          await clientSocket.close();
        } catch (error) {
          console.error(TAG, `[æœåŠ¡ç«¯] å…³é—­å®¢æˆ·ç«¯è¿æ¥å¤±è´¥: ${JSON.stringify(error)}`);
        }
      }
      this.clientSockets = [];
      this.clientCount = 0;
      
      this.isServerRunning = false;
      this.responseData += '[æœåŠ¡ç«¯] æœåŠ¡å·²åœæ­¢\n';
      console.log(TAG, '[æœåŠ¡ç«¯] æœåŠ¡å·²åœæ­¢');
    } catch (error) {
      console.error(TAG, `[æœåŠ¡ç«¯] åœæ­¢æœåŠ¡å¤±è´¥: ${JSON.stringify(error)}`);
      this.responseData += `[é”™è¯¯] åœæ­¢æœåŠ¡å¤±è´¥: ${JSON.stringify(error)}\n`;
    }
  }

  // å‘é€æœåŠ¡ç«¯å“åº”
  async sendServerResponse(receivedMessage: string, remoteInfo:socket.SocketRemoteInfo ) {
    try {
      if (!this.serverSocket) {
        return;
      }

      const response = `æœåŠ¡ç«¯æ”¶åˆ°: ${receivedMessage}`;
      
      // æ³¨æ„ï¼šæ ‡å‡†TCPSocketçš„sendæ–¹æ³•ç”¨äºå·²è¿æ¥çš„socket
      // å¯¹äºæœåŠ¡ç«¯æ¥æ”¶åˆ°çš„æ¶ˆæ¯ï¼Œéœ€è¦å‘å¯¹åº”çš„å®¢æˆ·ç«¯å‘é€å“åº”
      // è¿™é‡Œçš„å®ç°å–å†³äºå…·ä½“çš„APIæ”¯æŒæƒ…å†µ
      
      this.responseData += `[å‘é€] å“åº”: ${response}\n`;
      console.log(TAG, `[æœåŠ¡ç«¯] å‘é€å“åº”: ${response}`);
    } catch (error) {
      console.error(TAG, `[æœåŠ¡ç«¯] å‘é€å“åº”å¤±è´¥: ${JSON.stringify(error)}`);
      this.responseData += `[é”™è¯¯] å‘é€å“åº”å¤±è´¥: ${JSON.stringify(error)}\n`;
    }
  }

  // å¹¿æ’­æ¶ˆæ¯åˆ°æ‰€æœ‰å®¢æˆ·ç«¯
  async broadcastMessage() {
    if (!this.isServerRunning || this.clientCount === 0) {
      this.responseData += '[é”™è¯¯] æœåŠ¡æœªè¿è¡Œæˆ–æ— å®¢æˆ·ç«¯è¿æ¥\n';
      return;
    }

    try {
      this.responseData += `[å¹¿æ’­] å‘${this.clientCount}ä¸ªå®¢æˆ·ç«¯å‘é€: ${this.message}\n`;
      
      // éå†æ‰€æœ‰å·²è¿æ¥çš„å®¢æˆ·ç«¯å¹¶å‘é€æ¶ˆæ¯
      let successCount = 0;
      for (const clientSocket of this.clientSockets) {
        try {
          await clientSocket.send({
            data: this.message,
            encoding: 'utf8'
          });
          successCount++;
        } catch (error) {
          console.error(TAG, `[æœåŠ¡ç«¯] å‘é€å¤±è´¥: ${JSON.stringify(error)}`);
        }
      }
      
      this.responseData += `[å®Œæˆ] æˆåŠŸå‘é€åˆ°${successCount}ä¸ªå®¢æˆ·ç«¯\n`;
      console.log(TAG, `[æœåŠ¡ç«¯] å¹¿æ’­å®Œæˆï¼ŒæˆåŠŸ: ${successCount}/${this.clientCount}`);
    } catch (error) {
      console.error(TAG, `[æœåŠ¡ç«¯] å¹¿æ’­å¤±è´¥: ${JSON.stringify(error)}`);
      this.responseData += `[é”™è¯¯] å¹¿æ’­å¤±è´¥: ${JSON.stringify(error)}\n`;
    }
  }

  build() {
    Column() {
      Stack({ alignContent : Alignment.TopStart }) {
        TestImageDisplay({ testItem : this.testItem })
        PageTitle({ testItem : this.testItem })
      }

      Scroll() {
        Column() {
          // æ¨¡å¼é€‰æ‹©
          Text('è¿è¡Œæ¨¡å¼')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .width('100%')
            .margin({ top: 10, bottom: 10 })

          Row() {
            Button('å®¢æˆ·ç«¯æ¨¡å¼')
              .width('48%')
              .backgroundColor(this.mode === 'client' ? Color.Blue : Color.Gray)
              .onClick(() => {
                if (!this.isConnected && !this.isServerRunning) {
                  this.mode = 'client';
                  this.responseData = '';
                }
              })

            Button('æœåŠ¡ç«¯æ¨¡å¼')
              .width('48%')
              .backgroundColor(this.mode === 'server' ? Color.Blue : Color.Gray)
              .onClick(() => {
                if (!this.isConnected && !this.isServerRunning) {
                  this.mode = 'server';
                  this.responseData = '';
                }
              })
          }
          .width('100%')
          .justifyContent(FlexAlign.SpaceBetween)
          .margin({ bottom: 15 })

          // å®¢æˆ·ç«¯æ¨¡å¼é…ç½®
          if (this.mode === 'client') {
            Text('æœåŠ¡å™¨é…ç½®')
              .fontSize(18)
              .fontWeight(FontWeight.Bold)
              .width('100%')
              .margin({ top: 5, bottom: 10 })

            Row() {
              Text('æœåŠ¡å™¨åœ°å€: ')
                .fontSize(16)
                .width('30%')
              TextInput({ text: this.serverAddress })
                .width('70%')
                .borderRadius(5)
                .onChange((value: string) => {
                  this.serverAddress = value;
                })
            }
            .width('100%')
            .margin({ bottom: 10 })

            Row() {
              Text('ç«¯å£: ')
                .fontSize(16)
                .width('30%')
              TextInput({ text: this.serverPort })
                .width('70%')
                .borderRadius(5)
                .type(InputType.Number)
                .onChange((value: string) => {
                  this.serverPort = value;
                })
            }
            .width('100%')
            .margin({ bottom: 10 })
          }

          // æœåŠ¡ç«¯æ¨¡å¼é…ç½®
          if (this.mode === 'server') {
            Text('æœåŠ¡ç«¯é…ç½®')
              .fontSize(18)
              .fontWeight(FontWeight.Bold)
              .width('100%')
              .margin({ top: 5, bottom: 10 })

            Row() {
              Text('ç›‘å¬ç«¯å£: ')
                .fontSize(16)
                .width('30%')
              TextInput({ text: this.localPort })
                .width('70%')
                .borderRadius(5)
                .type(InputType.Number)
                .onChange((value: string) => {
                  this.localPort = value;
                })
            }
            .width('100%')
            .margin({ bottom: 10 })

            Row() {
              Text('æœåŠ¡çŠ¶æ€: ')
                .fontSize(16)
                .width('30%')
              Text(this.isServerRunning ? 'è¿è¡Œä¸­' : 'æœªå¯åŠ¨')
                .fontSize(16)
                .fontColor(this.isServerRunning ? Color.Green : Color.Gray)
                .width('70%')
            }
            .width('100%')
            .margin({ bottom: 10 })

            if (this.isServerRunning && this.clientCount > 0) {
              Row() {
                Text('è¿æ¥æ•°: ')
                  .fontSize(16)
                  .width('30%')
                Text(`${this.clientCount}`)
                  .fontSize(16)
                  .fontColor(Color.Blue)
                  .width('70%')
              }
              .width('100%')
              .margin({ bottom: 10 })
            }
          }

          // è¿æ¥çŠ¶æ€ï¼ˆå®¢æˆ·ç«¯æ¨¡å¼ï¼‰
          if (this.mode === 'client') {
            Row() {
              Text('è¿æ¥çŠ¶æ€: ')
                .fontSize(16)
                .width('30%')
              Text(this.connectionStatus)
                .fontSize(16)
                .fontColor(this.isConnected ? Color.Green : Color.Red)
                .width('70%')
            }
            .width('100%')
            .margin({ bottom: 10 })
          }

          // ç½‘ç»œçŠ¶æ€
          Row() {
            Text('ç½‘ç»œçŠ¶æ€: ')
              .fontSize(16)
              .width('30%')
            Text(`${this.networkStatus} (${this.networkType})`)
              .fontSize(16)
              .fontColor(this.networkStatus === 'ç½‘ç»œæ­£å¸¸' || this.networkStatus === 'ç½‘ç»œå¯ç”¨' ? Color.Green : Color.Orange)
              .width('70%')
          }
          .width('100%')
          .margin({ bottom: 10 })

          // é‡è¿æ¬¡æ•°ï¼ˆå®¢æˆ·ç«¯æ¨¡å¼ï¼‰
          if (this.mode === 'client' && this.reconnectCount > 0) {
            Row() {
              Text('é‡è¿æ¬¡æ•°: ')
                .fontSize(16)
                .width('30%')
              Text(`${this.reconnectCount}`)
                .fontSize(16)
                .fontColor(Color.Blue)
                .width('70%')
            }
            .width('100%')
            .margin({ bottom: 10 })
          }

          // æ“ä½œæŒ‰é’® - å®¢æˆ·ç«¯æ¨¡å¼
          if (this.mode === 'client') {
            Row() {
              Button('è¿æ¥')
                .width('22%')
                .backgroundColor(this.isConnected ? Color.Gray : Color.Blue)
                .enabled(!this.isConnected)
                .onClick(() => {
                  this.connectToServer();
                })

              Button('æ–­å¼€')
                .width('22%')
                .backgroundColor(!this.isConnected ? Color.Gray : Color.Red)
                .enabled(this.isConnected)
                .onClick(() => {
                  this.disconnectFromServer();
                })

              Button('æ¸…ç©º')
                .width('22%')
                .backgroundColor(Color.Orange)
                .onClick(() => {
                  this.clearResponse();
                })

              Button('å‘é€')
                .width('22%')
                .backgroundColor(!this.isConnected ? Color.Gray : Color.Green)
                .enabled(this.isConnected)
                .onClick(() => {
                  this.sendMessage();
                })
            }
            .width('100%')
            .justifyContent(FlexAlign.SpaceBetween)
            .margin({ bottom: 15 })
          }

          // æ“ä½œæŒ‰é’® - æœåŠ¡ç«¯æ¨¡å¼
          if (this.mode === 'server') {
            Row() {
              Button(this.isServerRunning ? 'åœæ­¢æœåŠ¡' : 'å¯åŠ¨æœåŠ¡')
                .width('30%')
                .backgroundColor(this.isServerRunning ? Color.Red : Color.Blue)
                .onClick(() => {
                  if (this.isServerRunning) {
                    this.stopServer();
                  } else {
                    this.startServer();
                  }
                })

              Button('æ¸…ç©ºæ—¥å¿—')
                .width('30%')
                .backgroundColor(Color.Orange)
                .onClick(() => {
                  this.clearResponse();
                })

              Button('å¹¿æ’­æ¶ˆæ¯')
                .width('30%')
                .backgroundColor(!this.isServerRunning || this.clientCount === 0 ? Color.Gray : Color.Green)
                .enabled(this.isServerRunning && this.clientCount > 0)
                .onClick(() => {
                  this.broadcastMessage();
                })
            }
            .width('100%')
            .justifyContent(FlexAlign.SpaceBetween)
            .margin({ bottom: 15 })
          }

          // æ¶ˆæ¯è¾“å…¥åŒºåŸŸ
          Text(this.mode === 'client' ? 'å‘é€æ¶ˆæ¯' : 'å¹¿æ’­æ¶ˆæ¯')
            .fontSize(16)
            .fontWeight(FontWeight.Bold)
            .width('100%')
            .margin({ bottom: 5 })

          TextInput({ text: this.message })
            .width('100%')
            .borderRadius(5)
            .onChange((value: string) => {
              this.message = value;
            })
            .margin({ bottom: 15 })

          // è¯´æ˜æç¤ºï¼ˆæœåŠ¡ç«¯æ¨¡å¼ï¼‰
          if (this.mode === 'server') {
            Row() {
              Text('ğŸ’¡ ')
                .fontSize(14)
                .fontColor(Color.Blue)
              Text('æœåŠ¡ç«¯æ¨¡å¼: ç›‘å¬æœ¬åœ°ç«¯å£ï¼Œç­‰å¾…å®¢æˆ·ç«¯è¿æ¥ã€‚å¯ä»¥å‘æ‰€æœ‰å·²è¿æ¥çš„å®¢æˆ·ç«¯å¹¿æ’­æ¶ˆæ¯ã€‚')
                .fontSize(12)
                .fontColor(Color.Blue)
            }
            .width('100%')
            .padding(8)
            .backgroundColor('#E3F2FD')
            .borderRadius(5)
            .margin({ bottom: 10 })
          }

          // å“åº”/æ—¥å¿—åŒºåŸŸ
          Text(this.mode === 'client' ? 'å“åº”æ•°æ®' : 'æœåŠ¡ç«¯æ—¥å¿—')
            .fontSize(16)
            .fontWeight(FontWeight.Bold)
            .width('100%')
            .margin({ bottom: 5 })

          TextArea({ text: this.responseData })
            .width('100%')
            .height(300)
            .borderRadius(5)
            .backgroundColor(Color.White)
            .margin({ bottom: 20 })
        }
        .width('100%')
        .padding(10)
      }
      .width('95%')
      .height('85%')
      .scrollable(ScrollDirection.Vertical)
      .scrollBar(BarState.Auto)
      .edgeEffect(EdgeEffect.Spring)
    }
    .size({ width: ConfigData.WH_100_100, height: ConfigData.WH_100_100 })
    .backgroundColor('#F5F5F5')
  }

  aboutToDisappear() {
    // å–æ¶ˆç½‘ç»œç›‘å¬
    if (this.netConnection) {
      try {
        this.netConnection.unregister((error: Error) => {
          if (error) {
            console.error(TAG, `å–æ¶ˆç½‘ç»œç›‘å¬å¤±è´¥: ${JSON.stringify(error)}`);
          } else {
            console.log(TAG, 'ç½‘ç»œç›‘å¬å·²å–æ¶ˆ');
          }
        });
      } catch (error) {
        console.error(TAG, `å–æ¶ˆç½‘ç»œç›‘å¬å¼‚å¸¸: ${JSON.stringify(error)}`);
      }
      this.netConnection = null;
    }

    // å…³é—­å®¢æˆ·ç«¯Socket
    if (this.tcpSocket) {
      this.tcpSocket.close();
      this.tcpSocket = null;
    }
    
    // å…³é—­æœåŠ¡ç«¯Socket
    if (this.serverSocket) {
      this.serverSocket.close();
      this.serverSocket = null;
    }
    
    // å…³é—­æ‰€æœ‰å®¢æˆ·ç«¯è¿æ¥
    for (const clientSocket of this.clientSockets) {
      try {
        clientSocket.close();
      } catch (error) {
        console.error(TAG, `å…³é—­å®¢æˆ·ç«¯è¿æ¥å¤±è´¥: ${JSON.stringify(error)}`);
      }
    }
    this.clientSockets = [];
    
    // æ¸…ç©ºè¿æ¥å‚æ•°
    this.lastConnectParams = null;
  }
}
